# ç³»ç»Ÿæ¶æ„æ–‡æ¡£

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° AI æ—…è¡ŒåŠ©æ‰‹çš„æŠ€æœ¯æ¶æ„ã€è®¾è®¡ç†å¿µå’Œå®ç°ç»†èŠ‚ã€‚

## ç›®å½•

- [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
- [å‰ç«¯æ¶æ„](#å‰ç«¯æ¶æ„)
- [åç«¯æ¶æ„](#åç«¯æ¶æ„)
- [æ•°æ®æµè®¾è®¡](#æ•°æ®æµè®¾è®¡)
- [æ ¸å¿ƒæ¨¡å—è¯¦è§£](#æ ¸å¿ƒæ¨¡å—è¯¦è§£)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [è®¾è®¡æ¨¡å¼](#è®¾è®¡æ¨¡å¼)

---

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ç”¨æˆ·æµè§ˆå™¨                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Vue 3 + TypeScript å‰ç«¯åº”ç”¨                â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”‚
â”‚  â”‚  â”‚ èŠå¤©ç•Œé¢ â”‚  â”‚ åœ°å›¾ç»„ä»¶ â”‚  â”‚ è·¯çº¿æŸ¥è¯¢ç»„ä»¶      â”‚    â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚
â”‚  â”‚       â”‚             â”‚             â”‚                    â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”‚
â”‚  â”‚  â”‚     Vue Router + Pinia çŠ¶æ€ç®¡ç†               â”‚    â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚
â”‚  â”‚                      â”‚                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”‚
â”‚  â”‚  â”‚          LocalStorage æœ¬åœ°ç¼“å­˜                 â”‚    â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ ä¼šè¯å†å²  â€¢ æ—…è¡Œè‰ç¨¿  â€¢ åœ°å›¾æ•°æ®  â€¢ è·¯çº¿ç¼“å­˜ â”‚    â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚ HTTP/SSE
                             â”‚ Port: 9000
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     FastAPI åç«¯æœåŠ¡                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                   API è·¯ç”±å±‚                            â”‚  â”‚
â”‚  â”‚  /api/chat  /api/hotel-chat  /api/batch-geocode       â”‚  â”‚
â”‚  â”‚  /api/multi-mode-route  /api/hotel-search             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                      â”‚                          â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     LLM æœåŠ¡å±‚             â”‚    â”‚   åœ°å›¾æœåŠ¡å±‚           â”‚ â”‚
â”‚  â”‚  â€¢ éœ€æ±‚åˆ†æ                â”‚    â”‚  â€¢ æ‰¹é‡åœ°ç†ç¼–ç         â”‚ â”‚
â”‚  â”‚  â€¢ è¡Œç¨‹ç”Ÿæˆ                â”‚    â”‚  â€¢ é©¾è½¦è·¯çº¿è§„åˆ’        â”‚ â”‚
â”‚  â”‚  â€¢ é…’åº—æ¨è                â”‚    â”‚  â€¢ æ­¥è¡Œè·¯çº¿è§„åˆ’        â”‚ â”‚
â”‚  â”‚  â€¢ JSON è§£æ               â”‚    â”‚  â€¢ å…¬äº¤è·¯çº¿è§„åˆ’        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚               â”‚                                â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                                â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   è±†åŒ… AI API     â”‚           â”‚  é«˜å¾·åœ°å›¾ Web API   â”‚
       â”‚  (ç«å±±å¼•æ“)        â”‚           â”‚  â€¢ Geocoding API   â”‚
       â”‚  â€¢ å¯¹è¯æ¨¡å‹       â”‚           â”‚  â€¢ Direction API   â”‚
       â”‚  â€¢ æ¨ç†æ¨¡å‹       â”‚           â”‚                    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆæ€»è§ˆ

| å±‚çº§ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|-----|---------|-----|
| **å‰ç«¯æ¡†æ¶** | Vue 3 Composition API | å“åº”å¼ã€ç»„åˆå¼ APIï¼Œå¼€å‘æ•ˆç‡é«˜ |
| **ç±»å‹ç³»ç»Ÿ** | TypeScript 5.8 | é™æ€ç±»å‹æ£€æŸ¥ï¼Œæå‡ä»£ç è´¨é‡ |
| **çŠ¶æ€ç®¡ç†** | Pinia + Reactive | è½»é‡çº§ã€ç±»å‹å‹å¥½çš„çŠ¶æ€ç®¡ç† |
| **è·¯ç”±** | Vue Router 4 | å•é¡µåº”ç”¨è·¯ç”±ç®¡ç† |
| **æ„å»ºå·¥å…·** | Vite 7 | æé€Ÿçš„å¼€å‘æœåŠ¡å™¨å’Œæ„å»ºå·¥å…· |
| **åç«¯æ¡†æ¶** | FastAPI | é«˜æ€§èƒ½ã€è‡ªåŠ¨æ–‡æ¡£ã€ç±»å‹éªŒè¯ |
| **LLM é›†æˆ** | OpenAI SDK + è±†åŒ… AI | å…¼å®¹ OpenAI API æ ¼å¼ |
| **åœ°å›¾æœåŠ¡** | é«˜å¾·åœ°å›¾ JS API 2.0 | å›½å†…è®¿é—®ç¨³å®šã€åŠŸèƒ½ä¸°å¯Œ |
| **çˆ¬è™«æ¡†æ¶** | Playwright | é…’åº—ä¿¡æ¯æŠ“å– |
| **æœ¬åœ°å­˜å‚¨** | LocalStorage | å®¢æˆ·ç«¯æŒä¹…åŒ–å­˜å‚¨ |

---

## å‰ç«¯æ¶æ„

### ç»„ä»¶ç»“æ„

```
frontend/src/
â”œâ”€â”€ main.ts                      # åº”ç”¨å…¥å£
â”œâ”€â”€ App.vue                      # æ ¹ç»„ä»¶
â”œâ”€â”€ router/
â”‚   â””â”€â”€ index.ts                 # è·¯ç”±é…ç½®
â”œâ”€â”€ stores/
â”‚   â””â”€â”€ counter.ts               # Pinia çŠ¶æ€ç®¡ç†ï¼ˆç¤ºä¾‹ï¼‰
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ HomeView.vue             # é¦–é¡µ
â”‚   â”œâ”€â”€ ChatView.vue             # æ—…è¡Œè§„åˆ’èŠå¤©ç•Œé¢ â­
â”‚   â”œâ”€â”€ HotelChatView.vue        # é…’åº—æ¨èèŠå¤©ç•Œé¢
â”‚   â”œâ”€â”€ TravelMapView.vue        # ç‹¬ç«‹åœ°å›¾é¡µé¢
â”‚   â””â”€â”€ AboutView.vue            # å…³äºé¡µé¢
â”œâ”€â”€ components/
â”‚   â””â”€â”€ TheWelcome.vue           # æ¬¢è¿ç»„ä»¶
â””â”€â”€ assets/
    â”œâ”€â”€ base.css                 # åŸºç¡€æ ·å¼
    â””â”€â”€ main.css                 # å…¨å±€æ ·å¼
```

### æ ¸å¿ƒç»„ä»¶ï¼šChatView.vue

`ChatView.vue` æ˜¯æœ€å¤æ‚ä¹Ÿæ˜¯æœ€æ ¸å¿ƒçš„å‰ç«¯ç»„ä»¶ï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½æ¨¡å—ï¼š

#### 1. æ•°æ®ç»“æ„è®¾è®¡

```typescript
// æ¶ˆæ¯å†…å®¹ç±»å‹
interface MessageContent {
  type: 'text' | 'image'
  text?: string
  image_url?: { url: string }
}

// ğŸ†• é…’åº—æ•°æ®æ¥å£
interface HotelData {
  name: string
  url?: string | null      // ğŸ†• é¢„è®¢é¡µé¢URL
  image?: string | null    // ğŸ†• é…’åº—å›¾ç‰‡URL
  price: string
  score: string
  location: string
  facilities: string[]
}

// æ¶ˆæ¯ç»“æ„
interface Message {
  role: 'user' | 'assistant' | 'system'
  content: MessageContent[] | string
  mapData?: MapData          // åœ°å›¾æ•°æ®ç¼“å­˜
  routesData?: RoutesDataMap // è·¯çº¿æ•°æ®ç¼“å­˜
  hotelsData?: HotelData[]   // ğŸ†• é…’åº—åˆ—è¡¨æ•°æ®ï¼ˆåŒ…å«URLå’Œå›¾ç‰‡ï¼‰
}

// åœ°å›¾æ•°æ®
interface MapData {
  itinerary: any[]
  city: string
  coordsMap: Record<string, number[]>
  mapId: string
}

// æ—…è¡Œè®¡åˆ’è‰ç¨¿
interface TravelPlanDraft {
  destination: string | null
  origin: string | null
  start_date: string | null
  end_date: string | null
  people: number | null
  attractions: string[]
}

// èŠå¤©ä¼šè¯
interface ChatSession {
  id: string
  title: string
  messages: Message[]
  draft?: TravelPlanDraft | null
  createdAt: number
}
```

#### 2. å“åº”å¼çŠ¶æ€ç®¡ç†

```typescript
// æ¶ˆæ¯å†å²
const messages = ref<Message[]>([])

// æ—…è¡Œè®¡åˆ’è‰ç¨¿ï¼ˆä¼šè¯çº§ï¼‰
const travelPlanDraft = ref<TravelPlanDraft | null>(null)

// è®¡ç®—å±æ€§
const isDraftMode = computed(() => travelPlanDraft.value !== null)
const draftCompleteness = computed(() => {
  // è®¡ç®—ä¿¡æ¯æ”¶é›†å®Œæˆåº¦ (0-100)
})
const draftMissingFields = computed(() => {
  // è¿”å›ç¼ºå¤±çš„å¿…å¡«å­—æ®µåˆ—è¡¨
})

// ä¼šè¯ç®¡ç†
const chatSessions = ref<ChatSession[]>([])
const currentSessionId = ref<string | null>(null)
```

#### 3. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

##### 3.1 å¤šè½®å¯¹è¯ç®¡ç†

```typescript
async function sendMessage() {
  // 1. æ™ºèƒ½åˆ¤æ–­æ˜¯å¦å¯åŠ¨è‰ç¨¿æ¨¡å¼
  if (!isDraftMode.value && isTravelRelated(userText)) {
    initDraft()
  }

  // 2. æ„å»ºè¯·æ±‚ï¼ˆåŒ…å«è‰ç¨¿ï¼‰
  const payload = {
    messages: normalizedMessages,
    travel_draft: travelPlanDraft.value || undefined
  }

  // 3. å‘é€è¯·æ±‚åˆ°åç«¯
  const response = await fetch('http://localhost:9000/api/chat', {
    method: 'POST',
    body: JSON.stringify(payload)
  })

  // 4. å¤„ç†å“åº”
  const result = await response.json()
  
  if (result.type === 'draft_update') {
    // æ›´æ–°è‰ç¨¿å¹¶æ˜¾ç¤ºè¿½é—®
    updateDraft(result.draft)
    // æ˜¾ç¤º next_question
  } else if (result.type === 'daily_plan_json') {
    // æ¸²æŸ“æ¯æ—¥è®¡åˆ’
    renderDailyPlan(result)
  }
}
```

##### 3.2 åœ°å›¾æ¸²æŸ“å¼•æ“

```typescript
async function renderTravelMap(
  msgIndex: number, 
  itinerary: any[], 
  city: string
): Promise<Map<string, number[]>> {
  
  // 1. æå–æ‰€æœ‰æ™¯ç‚¹åç§°
  const allPlaces = itinerary.flatMap(day => 
    day.activities.map((a: any) => a.name)
  )

  // 2. æ‰¹é‡åœ°ç†ç¼–ç 
  const response = await fetch('http://localhost:9000/api/batch-geocode', {
    method: 'POST',
    body: JSON.stringify({ places: allPlaces, city })
  })
  const { results } = await response.json()

  // 3. æ„å»ºåæ ‡æ˜ å°„
  const coordsMap = new Map<string, number[]>()
  results.forEach(r => {
    if (r.success) coordsMap.set(r.name, r.coords)
  })

  // 4. åˆå§‹åŒ–é«˜å¾·åœ°å›¾
  const map = new AMap.Map(mapId, {
    zoom: 13,
    center: firstCoords,
    mapStyle: 'amap://styles/normal'
  })

  // 5. ç»˜åˆ¶æ¯æ—¥è·¯çº¿ï¼ˆä¸åŒé¢œè‰²ï¼‰
  itinerary.forEach((day, dayIdx) => {
    const color = DAILY_COLORS[dayIdx % DAILY_COLORS.length]
    const dayCoords: number[][] = []

    day.activities.forEach((activity: any, actIdx: number) => {
      const coords = coordsMap.get(activity.name)
      if (coords) {
        // æ·»åŠ æ ‡è®°
        new AMap.Marker({
          position: coords,
          title: activity.name,
          label: { content: `D${day.day}-${actIdx + 1}` }
        })
        dayCoords.push(coords)
      }
    })

    // ç»˜åˆ¶è·¯çº¿
    if (dayCoords.length > 1) {
      new AMap.Polyline({
        path: dayCoords,
        strokeColor: color,
        strokeWeight: 4
      }).setMap(map)
    }
  })

  // 6. ç¼“å­˜åœ°å›¾æ•°æ®
  messages.value[msgIndex].mapData = {
    itinerary, city, coordsMap: Object.fromEntries(coordsMap), mapId
  }
  saveCurrentSession()

  return coordsMap
}
```

##### 3.3 è·¯çº¿æŸ¥è¯¢ä¸ç¼“å­˜

```typescript
async function populateRoutesForMessage(
  msgIndex: number, 
  city: string, 
  coordsMap?: Map<string, number[]>
) {
  
  // åˆå§‹åŒ–æ¶ˆæ¯çº§ç¼“å­˜
  if (!messages.value[msgIndex].routesData) {
    messages.value[msgIndex].routesData = {}
  }
  const messageRoutesCache = messages.value[msgIndex].routesData!

  // éå†æ‰€æœ‰è·¯çº¿æŒ‰é’®
  for (const chip of routeChips) {
    const origin = chip.getAttribute('data-origin')
    const destination = chip.getAttribute('data-destination')
    const routeKey = `${origin}->${destination}`

    // ä¸‰çº§ç¼“å­˜æ£€æŸ¥
    // 1. æ¶ˆæ¯çº§ç¼“å­˜
    if (messageRoutesCache[routeKey]) {
      updateRouteDisplay(chip, routeId, messageRoutesCache[routeKey])
      continue
    }

    // 2. LocalStorage ç¼“å­˜
    const cachedRoutes = getMultiModeRouteFromCache(city, origin, destination)
    if (cachedRoutes) {
      messageRoutesCache[routeKey] = cachedRoutes
      updateRouteDisplay(chip, routeId, cachedRoutes)
      continue
    }

    // 3. API è°ƒç”¨
    if (coordsMap?.has(origin) && coordsMap?.has(destination)) {
      const response = await fetch('http://localhost:9000/api/multi-mode-route', {
        method: 'POST',
        body: JSON.stringify({
          origin_coords: coordsMap.get(origin),
          destination_coords: coordsMap.get(destination),
          city
        })
      })
      const data = await response.json()
      
      // ä¿å­˜åˆ°ä¸‰çº§ç¼“å­˜
      setMultiModeRouteCache(city, origin, destination, data.routes)
      messageRoutesCache[routeKey] = data.routes
      updateRouteDisplay(chip, routeId, data.routes)
    }
  }

  saveCurrentSession()
}
```

##### 3.4 ä¼šè¯ç®¡ç†

```typescript
// åˆ›å»ºæ–°ä¼šè¯
function createNewChat() {
  const newSession: ChatSession = {
    id: generateId(),
    title: 'æ–°å¯¹è¯',
    messages: [],
    draft: null,
    createdAt: Date.now()
  }
  chatSessions.value.push(newSession)
  currentSessionId.value = newSession.id
  
  // é‡ç½®å½“å‰çŠ¶æ€
  messages.value = []
  travelPlanDraft.value = null
  
  saveSessions()
}

// åˆ‡æ¢ä¼šè¯
function loadChatSession(session: ChatSession) {
  currentSessionId.value = session.id
  messages.value = session.messages
  travelPlanDraft.value = session.draft || null
  
  // é‡æ–°æ¸²æŸ“ç¼“å­˜çš„åœ°å›¾
  nextTick(() => {
    rerenderCachedMaps()
  })
}

// ä¿å­˜å½“å‰ä¼šè¯
function saveCurrentSession() {
  const session = chatSessions.value.find(s => s.id === currentSessionId.value)
  if (session) {
    session.messages = messages.value
    session.draft = travelPlanDraft.value
    saveSessions()
  }
}

// æŒä¹…åŒ–æ‰€æœ‰ä¼šè¯
function saveSessions() {
  localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(chatSessions.value))
}
```

##### 3.5 é…’åº—å¡ç‰‡åµŒå…¥æ¸²æŸ“ ğŸ†•

```typescript
// ç±»å‹å®šä¹‰
type TextSegment = { type: 'text', content: string }
type HotelSegment = { type: 'hotel', hotel: HotelData }
type Segment = TextSegment | HotelSegment

// ç±»å‹å®ˆå«å‡½æ•°
const isHotelSegment = (segment: Segment): segment is HotelSegment => {
  return segment.type === 'hotel'
}

/**
 * è§£ææ–‡æœ¬ä¸­çš„é…’åº—å¡ç‰‡å ä½ç¬¦
 * LLM è¾“å‡ºæ ¼å¼ï¼šæ¨èæ–‡æœ¬ + [HOTEL_CARD:0] + æ¨èæ–‡æœ¬ + [HOTEL_CARD:1]
 */
const parseTextWithHotelCards = (
  text: string | undefined, 
  hotelsData: HotelData[]
): Segment[] => {
  if (!text) return [{ type: 'text', content: '' }]
  
  const segments: Segment[] = []
  const hotelCardRegex = /\[HOTEL_CARD:(\d+)\]/g
  
  let lastIndex = 0
  let match
  
  while ((match = hotelCardRegex.exec(text)) !== null) {
    // æ·»åŠ å ä½ç¬¦ä¹‹å‰çš„æ–‡æœ¬
    if (match.index > lastIndex) {
      const textContent = text.substring(lastIndex, match.index)
      if (textContent.trim()) {
        segments.push({ type: 'text', content: textContent })
      }
    }
    
    // æ·»åŠ é…’åº—å¡ç‰‡
    const hotelIndex = parseInt(match[1])
    if (hotelIndex >= 0 && hotelIndex < hotelsData.length) {
      segments.push({ type: 'hotel', hotel: hotelsData[hotelIndex] })
    }
    
    lastIndex = match.index + match[0].length
  }
  
  // æ·»åŠ æœ€åå‰©ä½™çš„æ–‡æœ¬
  if (lastIndex < text.length) {
    const textContent = text.substring(lastIndex)
    if (textContent.trim()) {
      segments.push({ type: 'text', content: textContent })
    }
  }
  
  return segments.length > 0 ? segments : [{ type: 'text', content: text }]
}

// æ¨¡æ¿æ¸²æŸ“
<template v-for="(segment, segmentIndex) in parseTextWithHotelCards(content.text, message.hotelsData)">
  <!-- æ–‡æœ¬æ®µï¼šMarkdown æ¸²æŸ“ -->
  <div v-if="segment.type === 'text'" 
       class="message-text markdown-body" 
       v-html="renderMarkdown(segment.content)">
  </div>
  
  <!-- é…’åº—æ®µï¼šæ˜¾ç¤ºé…’åº—å¡ç‰‡ -->
  <template v-else-if="isHotelSegment(segment)">
    <div class="hotel-card-inline">
      <div class="hotel-card">
        <img v-if="segment.hotel.image" 
             :src="segment.hotel.image" 
             :alt="segment.hotel.name" />
        <div class="hotel-info">
          <h3>{{ segment.hotel.name }}</h3>
          <div class="hotel-price">{{ segment.hotel.price }}</div>
          <div class="hotel-score">â­ {{ segment.hotel.score }}</div>
          <div class="hotel-location">ğŸ“ {{ segment.hotel.location }}</div>
          <a v-if="segment.hotel.url" 
             :href="segment.hotel.url" 
             target="_blank"
             class="booking-btn">
            ç«‹å³é¢„è®¢ â†’
          </a>
        </div>
      </div>
    </div>
  </template>
</template>
```

**å…³é”®ç‰¹æ€§**ï¼š
- **å ä½ç¬¦è§£æ**ï¼šä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… `[HOTEL_CARD:X]` å ä½ç¬¦
- **ç±»å‹å®‰å…¨**ï¼šä½¿ç”¨ TypeScript è”åˆç±»å‹å’Œç±»å‹å®ˆå«ç¡®ä¿ç±»å‹å®‰å…¨
- **æ— ç¼åµŒå…¥**ï¼šé…’åº—å¡ç‰‡åµŒå…¥åˆ°æ¨èæ–‡æœ¬çš„å¯¹åº”ä½ç½®ï¼Œè€Œéç»Ÿä¸€æ˜¾ç¤ºåœ¨æœ«å°¾
- **å“åº”å¼è®¾è®¡**ï¼šé…’åº—å¡ç‰‡æ”¯æŒå“åº”å¼å¸ƒå±€ï¼Œé€‚é…ä¸åŒå±å¹•å°ºå¯¸

---

## åç«¯æ¶æ„

### æ¨¡å—ç»“æ„

```
backend/
â”œâ”€â”€ main.py                 # ä¸»åº”ç”¨ï¼ˆFastAPIï¼‰
â”œâ”€â”€ hotel_agent.py          # é…’åº—æ¨èä»£ç†ï¼ˆæ„å›¾åˆ†æã€æ¨èç”Ÿæˆï¼‰
â””â”€â”€ booking_hotel_search.py # Booking.com çˆ¬è™«ï¼ˆé…’åº—æœç´¢ã€æ•°æ®æå–ï¼‰
```

### æ ¸å¿ƒæ¨¡å—ï¼šmain.py

#### 1. API è·¯ç”±è®¾è®¡

```python
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="AI æ—…è¡ŒåŠ©æ‰‹ API")

# é…ç½® CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# è·¯ç”±åˆ—è¡¨
@app.post("/api/chat")                # LLM å¯¹è¯
@app.post("/api/hotel-chat")          # é…’åº—æ¨èï¼ˆSSEï¼‰
@app.post("/api/batch-geocode")       # æ‰¹é‡åœ°ç†ç¼–ç 
@app.post("/api/multi-mode-route")    # å¤šæ¨¡å¼è·¯çº¿
@app.post("/api/amap-route-test")     # å•æ¬¡è·¯çº¿æµ‹è¯•
@app.post("/api/amap-route-direct")   # ç›´æ¥åæ ‡è·¯çº¿
@app.post("/api/hotel-search")        # é…’åº—æœç´¢
```

#### 2. LLM åŒé˜¶æ®µå¤„ç†

##### é˜¶æ®µ 1ï¼šéœ€æ±‚åˆ†æ

```python
INTENT_PROMPT = """
ä½ æ˜¯æ—…è¡Œè§„åˆ’åŠ©æ‰‹ï¼ŒèŒè´£ï¼šæ”¶é›†æ—…è¡Œå¿…å¡«ä¿¡æ¯ã€‚

ã€å½“å‰æ”¶é›†åˆ°çš„ä¿¡æ¯ã€‘ï¼š
{draft_info}

ã€è¾“å‡ºæ ¼å¼ã€‘ä¸¥æ ¼JSONï¼Œæ— ä»»ä½•é¢å¤–æ–‡å­—ï¼

ã€è¾“å‡ºç±»å‹ã€‘
1. æ™®é€šèŠå¤©ï¼š{"type":"chat","content":"..."}
2. æ”¶é›†ä¿¡æ¯ï¼š{"type":"draft_update","updates":{...},"draft":{...},"missing_required":[...],"is_complete":true/false,"next_question":"..."}

ã€æ ¸å¿ƒè§„åˆ™ã€‘
ä½ åªè´Ÿè´£æ”¶é›†4ä¸ªå¿…å¡«å­—æ®µï¼š
1. destination - ç›®çš„åœ°åŸå¸‚
2. origin - å‡ºå‘åœ°åŸå¸‚
3. start_date - å¼€å§‹æ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
4. end_date - ç»“æŸæ—¥æœŸï¼ˆYYYY-MM-DDï¼‰

ã€å¯é€‰å­—æ®µ - ä¸è¦è¿½é—®ã€‘
- peopleï¼šäººæ•°ï¼ˆç”¨æˆ·æåˆ°å°±è®°å½•ï¼Œæ²¡æåˆ°å°±nullï¼‰
- attractionsï¼šæ™¯ç‚¹åˆ—è¡¨ï¼ˆç”¨æˆ·æåˆ°å°±è®°å½•ï¼Œæ²¡æåˆ°å°±nullæˆ–[]ï¼‰
âŒ ç»å¯¹ä¸è¦ä¸»åŠ¨è¯¢é—®ï¼š"è¿˜æƒ³å»å“ªäº›æ™¯ç‚¹"ã€"æƒ³å»ä»€ä¹ˆåœ°æ–¹"
âœ… ç”¨æˆ·æ²¡ææ™¯ç‚¹å¾ˆæ­£å¸¸ï¼Œæˆ‘ä»¬ä¼šè‡ªåŠ¨æ¨è
"""

@app.post("/api/chat")
async def chat_endpoint(request: ChatRequest):
    # æ£€æŸ¥æ˜¯å¦ä¸ºè®¡åˆ’ç”Ÿæˆè¯·æ±‚
    last_message = request.messages[-1].content
    if isinstance(last_message, str) and last_message == "__GENERATE_PLAN__":
        # è·³è½¬åˆ°é˜¶æ®µ2
        return await generate_plan(request)
    
    # é˜¶æ®µ1ï¼šéœ€æ±‚åˆ†æ
    intent_resp = client.chat.completions.create(
        model=request.model,
        messages=[{"role": "system", "content": INTENT_PROMPT}, ...],
        temperature=0.3
    )
    
    intent_data = extract_first_json(intent_resp.choices[0].message.content)
    
    if intent_data.get("type") == "draft_update":
        return {
            "type": "draft_update",
            "updates": intent_data.get("updates", {}),
            "draft": intent_data.get("draft", {}),
            "missing_required": intent_data.get("missing_required", []),
            "is_complete": intent_data.get("is_complete", False),
            "next_question": intent_data.get("next_question", "")
        }
```

##### é˜¶æ®µ 2ï¼šè¡Œç¨‹ç”Ÿæˆ

```python
PLAN_GENERATION_PROMPT = """
ä½ æ˜¯ä¸“ä¸šçš„æ—…è¡Œè§„åˆ’å¸ˆï¼Œæ ¹æ®ç”¨æˆ·éœ€æ±‚ç”Ÿæˆè¯¦ç»†çš„æ¯æ—¥è¡Œç¨‹ã€‚

ã€ç”¨æˆ·éœ€æ±‚ã€‘
{draft_json}

ã€è¾“å‡ºæ ¼å¼ã€‘ä¸¥æ ¼JSONï¼Œæ— ä»»ä½•é¢å¤–æ–‡å­—ï¼
è¾“å‡ºæ ¼å¼ï¼š{"type":"daily_plan_json","plan":{...},"itinerary":[...]}

ã€è¡Œç¨‹è§„åˆ’è§„åˆ™ã€‘
1. å¦‚æœç”¨æˆ·æŒ‡å®šäº†æ™¯ç‚¹ï¼ˆattractionsï¼‰ï¼Œå¿…é¡»åŒ…å«åœ¨è¡Œç¨‹ä¸­ï¼Œä½†ä¸å±€é™äºå®ƒä»¬
2. å¦‚æœç”¨æˆ·æ²¡æŒ‡å®šæ™¯ç‚¹ï¼Œä½ è¦æ ¹æ®ç›®çš„åœ°æ¨èçƒ­é—¨æ™¯ç‚¹
3. æ’æœŸè§„åˆ™ï¼š
   - å…¨å¤©æ™¯ç‚¹ï¼ˆæ¸¸ä¹å›­/çˆ¬å±±ç­‰ï¼‰ï¼šå•ç‹¬å®‰æ’ä¸€å¤©
   - åŸå¸‚æ‰“å¡ç±»ï¼ˆå¯ºåº™/åšç‰©é¦†ç­‰ï¼‰ï¼šæ¯å¤©å®‰æ’3-4ä¸ªï¼Œä¿æŒç›¸é‚»æ™¯ç‚¹å¯æ­¥è¡Œæˆ–çŸ­é€”é€šå‹¤
4. æ¯å¤©è¡Œç¨‹åŒ…å«ï¼š
   - day: å¤©æ•°
   - date: æ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
   - title: æ ‡é¢˜ï¼ˆå¦‚"Day 1"ï¼‰
   - activities: [{"name":"æ™¯ç‚¹å", "notes":"å¯é€‰è¯´æ˜"}]
   - summary: å½“å¤©æ€»ç»“ï¼ˆäº¤é€šæ–¹å¼ã€æ³¨æ„äº‹é¡¹ç­‰ï¼‰
5. æ´»åŠ¨åç§°å¿…é¡»æ˜¯å•ä¸€ã€æ ‡å‡†åŒ–çš„ä¸­æ–‡æ™¯ç‚¹å®˜æ–¹åç§°
6. planå­—æ®µåŒ…å«ï¼šdestination, origin, start_date, end_date, peopleï¼ˆé»˜è®¤2ï¼‰ï¼Œ**cityï¼ˆå¿…å¡«ï¼‰**

ã€é‡è¦ï¼šåŸå¸‚è¯†åˆ«ã€‘
- å¿…é¡»åœ¨planä¸­æ·»åŠ "city"å­—æ®µ
- åˆ†æç›®çš„åœ°(destination)ï¼Œæå–æ‰€å±çš„**åŸå¸‚åç§°**
- ä¾‹å¦‚ï¼šdestination="ä¸Šæµ·è¿ªå£«å°¼" â†’ city="ä¸Šæµ·"
- ä¾‹å¦‚ï¼šdestination="è¥¿æ¹–" â†’ city="æ­å·"
- cityå­—æ®µç”¨äºå…¬äº¤è·¯çº¿æŸ¥è¯¢ï¼Œå¿…é¡»æ˜¯æ ‡å‡†çš„åŸå¸‚åç§°ï¼ˆä¸å¸¦"å¸‚"å­—ï¼‰
"""

async def generate_plan(request: ChatRequest):
    draft = request.travel_draft.dict()
    
    # éªŒè¯å¿…å¡«å­—æ®µ
    required = ["destination", "origin", "start_date", "end_date"]
    missing = [f for f in required if not draft.get(f)]
    if missing:
        raise HTTPException(400, detail=f"ç¼ºå°‘å¿…å¡«å­—æ®µ: {missing}")
    
    # è°ƒç”¨ LLM ç”Ÿæˆè®¡åˆ’
    plan_resp = client.chat.completions.create(
        model=request.model,
        messages=[
            {"role": "system", "content": PLAN_GENERATION_PROMPT.format(draft_json=json.dumps(draft))},
            {"role": "user", "content": f"è¯·ä¸ºæˆ‘è§„åˆ’{draft['destination']}çš„æ—…è¡Œ"}
        ],
        temperature=0.7,
        max_tokens=4000
    )
    
    plan_data = extract_first_json(plan_resp.choices[0].message.content)
    
    if plan_data.get("type") == "daily_plan_json":
        return {
            "type": "daily_plan_json",
            "plan": plan_data.get("plan", {}),
            "itinerary": plan_data.get("itinerary", [])
        }
```

#### 3. JSON è§£æå¼•æ“

```python
def extract_first_json(text: str) -> dict:
    """æå–ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„JSONå¯¹è±¡ï¼ˆæ”¯æŒåµŒå¥—æ•°ç»„å’Œå¯¹è±¡ï¼‰"""
    
    # 1. ç›´æ¥å°è¯•è§£æ
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        pass
    
    # 2. ä½¿ç”¨æ ˆåŒ¹é…æ‹¬å·ï¼ˆæ”¯æŒ {} å’Œ []ï¼‰
    start_idx = text.find('{')
    if start_idx == -1:
        return {"type": "chat", "content": text}
    
    bracket_stack = []
    in_string = False
    escape = False
    
    for i in range(start_idx, len(text)):
        char = text[i]
        
        # å¤„ç†è½¬ä¹‰å’Œå­—ç¬¦ä¸²
        if escape:
            escape = False
            continue
        if char == '\\':
            escape = True
            continue
        if char == '"':
            in_string = not in_string
            continue
        
        # éå­—ç¬¦ä¸²å†…å®¹çš„æ‹¬å·åŒ¹é…
        if not in_string:
            if char == '{':
                bracket_stack.append('{')
            elif char == '[':
                bracket_stack.append('[')
            elif char == '}':
                if bracket_stack and bracket_stack[-1] == '{':
                    bracket_stack.pop()
                    if len(bracket_stack) == 0:
                        # æ‰¾åˆ°å®Œæ•´ JSON
                        json_str = text[start_idx:i+1]
                        try:
                            return json.loads(json_str)
                        except Exception as e:
                            logger.error(f"JSONè§£æå¤±è´¥: {e}")
                            pass
                        break
            elif char == ']':
                if bracket_stack and bracket_stack[-1] == '[':
                    bracket_stack.pop()
    
    # 3. å›é€€ï¼šå°è¯•è§£ææ•´ä¸ªæ–‡æœ¬
    try:
        return json.loads(text)
    except:
        pass
    
    # 4. å¤±è´¥ï¼šè¿”å›èŠå¤©æ¨¡å¼
    return {"type": "chat", "content": text}
```

#### 4. é«˜å¾·åœ°å›¾æœåŠ¡å°è£…

```python
def _amap_geocode_sync(place_name: str, city: Optional[str] = None) -> Optional[dict]:
    """åœ°ç†ç¼–ç ï¼šåœ°å -> åæ ‡"""
    params = {"address": place_name, "key": AMAP_KEY}
    if city:
        params["city"] = city
    
    url = "https://restapi.amap.com/v3/geocode/geo?" + urllib.parse.urlencode(params)
    
    with urllib.request.urlopen(url, timeout=10) as resp:
        data = json.loads(resp.read().decode("utf-8"))
    
    if data.get("status") == "1" and data.get("geocodes"):
        geo = data["geocodes"][0]
        return {
            "location": geo["location"],  # "lng,lat"
            "poi": geo.get("formatted_address", place_name)
        }
    return None

def _amap_direction_sync(
    origin_loc: str, 
    dest_loc: str, 
    mode: str = "driving", 
    city: str = None
) -> Optional[dict]:
    """è·¯çº¿è§„åˆ’ï¼šæ”¯æŒé©¾è½¦ã€æ­¥è¡Œã€å…¬äº¤"""
    
    if mode == "walking":
        path = "/v3/direction/walking"
        params = {"origin": origin_loc, "destination": dest_loc, "key": AMAP_KEY}
    
    elif mode == "transit":
        if not city:
            logger.warning("âš ï¸ å…¬äº¤è·¯çº¿æŸ¥è¯¢ç¼ºå°‘åŸå¸‚å‚æ•°")
            return None
        path = "/v3/direction/transit/integrated"
        params = {
            "origin": origin_loc,
            "destination": dest_loc,
            "key": AMAP_KEY,
            "city": city,
            "cityd": city
        }
    
    else:  # driving
        path = "/v3/direction/driving"
        params = {"origin": origin_loc, "destination": dest_loc, "key": AMAP_KEY}
    
    url = "https://restapi.amap.com" + path + "?" + urllib.parse.urlencode(params)
    
    with urllib.request.urlopen(url, timeout=10) as resp:
        data = json.loads(resp.read().decode("utf-8"))
    
    if data.get("status") != "1":
        return None
    
    # è§£æä¸åŒæ¨¡å¼çš„è¿”å›æ•°æ®
    if mode == "transit":
        route = data.get("route", {})
        transits = route.get("transits", [])
        if not transits:
            return None
        t0 = transits[0]
        dist_m = int(t0.get("distance", 0))
        dur_s = int(t0.get("duration", 0))
        
        # æå–æ¢ä¹˜æ­¥éª¤
        steps = []
        for seg in t0.get("segments", []):
            bus_lines = seg.get("bus", {}).get("buslines", [])
            if bus_lines:
                steps.append({
                    "type": "bus",
                    "name": bus_lines[0].get("name", "å…¬äº¤"),
                    "via_stops": bus_lines[0].get("via_num", 0)
                })
            
            walking = seg.get("walking", {})
            if walking and walking.get("distance"):
                walk_dist = int(walking.get("distance", 0))
                if walk_dist > 0:
                    steps.append({
                        "type": "walk",
                        "distance": round(walk_dist / 1000, 2)
                    })
    
    else:  # driving / walking
        route = data.get("route", {})
        paths = route.get("paths", [])
        if not paths:
            return None
        p0 = paths[0]
        dist_m = int(p0.get("distance", 0))
        dur_s = int(p0.get("duration", 0))
        
        # æå–è¯¦ç»†æ­¥éª¤
        steps = []
        for step in p0.get("steps", []):
            instruction = step.get("instruction", "")
            road = step.get("road", "")
            distance = step.get("distance", "")
            if instruction or road:
                steps.append({
                    "instruction": instruction or f"æ²¿{road}è¡Œé©¶",
                    "road": road,
                    "distance": distance
                })
    
    return {
        "distance_km": round(dist_m / 1000, 1),
        "duration_min": max(1, round(dur_s / 60)),
        "steps": steps if steps else None
    }
```

#### 5. é…’åº—æ¨èæ¨¡å—

##### 5.1 é…’åº—æœç´¢ï¼ˆbooking_hotel_search.pyï¼‰

```python
async def search_hotel(
    destination: str,
    checkin_date: Optional[str] = None,
    checkout_date: Optional[str] = None,
    adults: int = 2,
    children: int = 0,
    rooms: int = 1
) -> Dict:
    """
    ä½¿ç”¨ Playwright è‡ªåŠ¨åŒ–æœç´¢ Booking.com é…’åº—
    
    è¿”å›æ•°æ®ç»“æ„ï¼š
    {
        "success": bool,
        "hotels": [
            {
                "name": "é…’åº—åç§°",
                "url": "https://booking.cn/hotel/...",  # ğŸ†• é¢„è®¢é¡µé¢URL
                "image": "https://cf.bstatic.com/...",  # ğŸ†• é…’åº—å›¾ç‰‡URL
                "price": "Â¥ 1,500",
                "score": "9.2",
                "location": "ä½ç½®ä¿¡æ¯",
                "facilities": ["WiFi", "åœè½¦åœº"]
            }
        ],
        "error": Optional[str]
    }
    """
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        page = await browser.new_page()
        
        # 1. è®¿é—® Booking.com
        await page.goto("https://booking.cn/index.zh-cn.html")
        
        # 2. å¤„ç† Cookie å¼¹çª—
        await handle_cookie_consent(page)
        
        # 3. è¾“å…¥æœç´¢æ¡ä»¶
        await page.get_by_role("combobox", name="ç›®çš„åœ°ï¼Ÿ").fill(destination)
        # ... è®¾ç½®æ—¥æœŸã€äººæ•°ç­‰
        
        # 4. ç‚¹å‡»æœç´¢
        await page.get_by_role("button", name="æœç‰¹ä»·").click()
        
        # 5. ç­‰å¾…ç»“æœåŠ è½½
        await page.wait_for_selector('[data-testid="property-card"]')
        
        # 6. æå–é…’åº—ä¿¡æ¯
        hotels = await page.locator('[data-testid="property-card"]').all()
        for hotel in hotels[:10]:
            hotel_info = {}
            # æå–åç§°
            hotel_info["name"] = await hotel.locator('[data-testid="title"]').inner_text()
            
            # ğŸ†• æå–é¢„è®¢URL
            url_element = hotel.locator('a[data-testid="title-link"]').first
            hotel_url = await url_element.get_attribute('href')
            if hotel_url and not hotel_url.startswith('http'):
                hotel_url = f"https://booking.cn{hotel_url}"
            hotel_info["url"] = hotel_url
            
            # ğŸ†• æå–å›¾ç‰‡URL
            img_element = hotel.locator('img').first
            hotel_info["image"] = await img_element.get_attribute('src')
            
            # æå–ä»·æ ¼ã€è¯„åˆ†ã€ä½ç½®ç­‰
            # ...
        
        await browser.close()
        return result
```

##### 5.2 é…’åº—æ¨èä»£ç†ï¼ˆhotel_agent.pyï¼‰

```python
class HotelAgent:
    """æ™ºèƒ½é…’åº—æ¨èä»£ç†"""
    
    def analyze_intent(self, user_message: str, travel_plan: Optional[Dict] = None) -> Dict:
        """
        åˆ†æç”¨æˆ·æ„å›¾å¹¶æå–å‚æ•°
        
        ğŸ†• æ”¯æŒä»æ—…è¡Œè®¡åˆ’ä¸­æå–ä¿¡æ¯ï¼š
        - å½“ç”¨æˆ·æåˆ°"ç¬¬Xå¤©"æ—¶ï¼Œä»è®¡åˆ’ä¸­æå–å¯¹åº”æ—¥æœŸå’Œæ™¯ç‚¹
        - è‡ªåŠ¨æ¨æ–­åˆé€‚çš„é…’åº—ä½ç½®
        """
        # å¦‚æœæœ‰æ—…è¡Œè®¡åˆ’ï¼Œæ·»åŠ åˆ°æç¤ºè¯ä¸­
        if travel_plan:
            travel_plan_json = json.dumps(travel_plan, ensure_ascii=False)
            user_content = f"""ç”¨æˆ·æ¶ˆæ¯ï¼š{user_message}
            
ã€ç”¨æˆ·çš„æ—…è¡Œè®¡åˆ’ã€‘
{travel_plan_json}
"""
        
        response = self.client.chat.completions.create(...)
        return json.loads(response.choices[0].message.content)
    
    async def search_hotels(self, params: Dict) -> Dict:
        """å¼‚æ­¥æœç´¢é…’åº—"""
        return await search_hotel(
            destination=params.get("destination"),
            checkin_date=params.get("checkin_date"),
            checkout_date=params.get("checkout_date"),
            adults=params.get("adults", 2)
        )
    
    def generate_recommendations(
        self, 
        user_message: str, 
        search_result: Dict, 
        travel_plan: Optional[Dict] = None
    ):
        """
        ç”Ÿæˆé…’åº—æ¨èï¼ˆæµå¼è¾“å‡ºï¼‰
        
        ğŸ†• å…³é”®ç‰¹æ€§ï¼š
        1. LLM åœ¨æ¨èæ–‡æœ¬ä¸­æ’å…¥å ä½ç¬¦ [HOTEL_CARD:X]
        2. X æ˜¯é…’åº—åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•ï¼ˆ0, 1, 2...ï¼‰
        3. å ä½ç¬¦å¿…é¡»å•ç‹¬å ä¸€è¡Œ
        4. å‰ç«¯è§£æå ä½ç¬¦å¹¶æ›¿æ¢ä¸ºå®é™…é…’åº—å¡ç‰‡
        """
        RECOMMENDATION_SYSTEM_PROMPT = """
        ...
        ğŸ¯ é‡è¦ï¼šé…’åº—å¡ç‰‡å ä½ç¬¦ä½¿ç”¨è§„åˆ™
        - åœ¨æ¨èæ¯ä¸ªé…’åº—æ—¶ï¼Œåœ¨æ¨èç†ç”±æ®µè½çš„**æœ€å**æ·»åŠ å ä½ç¬¦ [HOTEL_CARD:X]
        - X æ˜¯é…’åº—åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•ï¼ˆä»0å¼€å§‹ï¼‰
        - å ä½ç¬¦å¿…é¡»å•ç‹¬å ä¸€è¡Œ
        
        ç¤ºä¾‹ï¼š
        1. ä¸Šæµ·å›½é™…æ—…æ¸¸åº¦å‡åŒºæ™ºé€‰å‡æ—¥é…’åº—
        ä»·æ ¼ï¼šHK$ 518
        æ¨èç†ç”±ï¼š...
        [HOTEL_CARD:0]
        """
        
        stream = self.client.chat.completions.create(
            model="doubao-1-5-thinking-vision-pro-250428",
            messages=[...],
            stream=True
        )
        
        for chunk in stream:
            if chunk.choices[0].delta.content:
                yield chunk.choices[0].delta.content
```

##### 5.3 SSE æµå¼å“åº”ï¼ˆmain.pyï¼‰

```python
@app.post("/api/hotel-chat")
async def hotel_chat(request: HotelChatRequest):
    """é…’åº—æ¨èæ¥å£ï¼ˆSSEæµå¼ï¼‰"""
    
    async def generate_hotel_stream():
        # æ­¥éª¤1: æ„å›¾åˆ†æ
        yield f"data: {json.dumps({'step': 1, 'status': 'running'})}\n\n"
        intent_result = await hotel_agent.analyze_intent(
            request.message, 
            request.travel_plan  # ğŸ†• ä¼ é€’æ—…è¡Œè®¡åˆ’
        )
        yield f"data: {json.dumps({'step': 1, 'status': 'completed'})}\n\n"
        
        # æ­¥éª¤2: å‚æ•°éªŒè¯
        # ...
        
        # æ­¥éª¤3: æœç´¢é…’åº—
        search_result = await hotel_agent.search_hotels(params)
        yield f"data: {json.dumps({'step': 3, 'status': 'completed'})}\n\n"
        
        # æ­¥éª¤4: ç”Ÿæˆæ¨èï¼ˆæµå¼ï¼‰
        yield f"data: {json.dumps({'type': 'recommendation_start'})}\n\n"
        
        for chunk in hotel_agent.generate_recommendations(
            request.message, 
            search_result, 
            request.travel_plan  # ğŸ†• ä¼ é€’æ—…è¡Œè®¡åˆ’
        ):
            yield f"data: {json.dumps({'type': 'recommendation_chunk', 'content': chunk})}\n\n"
        
        yield f"data: {json.dumps({'type': 'recommendation_end'})}\n\n"
        
        # ğŸ†• å‘é€å®Œæ•´çš„é…’åº—åˆ—è¡¨æ•°æ®ï¼ˆåŒ…å«URLå’Œå›¾ç‰‡ï¼‰
        hotels_data = search_result.get("hotels", [])
        yield f"data: {json.dumps({'type': 'hotels_data', 'hotels': hotels_data})}\n\n"
        
        yield f"data: {json.dumps({'type': 'done'})}\n\n"
    
    return StreamingResponse(generate_hotel_stream(), media_type="text/event-stream")
```

---

## æ•°æ®æµè®¾è®¡

### 1. æ—…è¡Œè§„åˆ’æµç¨‹

```
ç”¨æˆ·è¾“å…¥ "æˆ‘æƒ³å»ä¸Šæµ·ç©"
    â”‚
    â”œâ”€â†’ å‰ç«¯æ£€æµ‹ï¼šisTravelRelated() = true
    â”‚       â””â”€â†’ åˆå§‹åŒ–è‰ç¨¿ï¼šinitDraft()
    â”‚
    â”œâ”€â†’ å‘é€åˆ°åç«¯ï¼šPOST /api/chat
    â”‚       Body: {messages: [...], travel_draft: {...}}
    â”‚
    â”œâ”€â†’ åç«¯ï¼šéœ€æ±‚åˆ†æLLMï¼ˆé˜¶æ®µ1ï¼‰
    â”‚       â”œâ”€â†’ æç¤ºè¯æ³¨å…¥å½“å‰è‰ç¨¿ä¿¡æ¯
    â”‚       â”œâ”€â†’ LLM åˆ†æå¹¶æå–å­—æ®µ
    â”‚       â””â”€â†’ è¿”å›ï¼šdraft_update + next_question
    â”‚
    â”œâ”€â†’ å‰ç«¯ï¼šæ›´æ–°è‰ç¨¿
    â”‚       â”œâ”€â†’ updateDraft(result.draft)
    â”‚       â”œâ”€â†’ æ˜¾ç¤º next_question
    â”‚       â””â”€â†’ ä¿å­˜åˆ° LocalStorage
    â”‚
    â”œâ”€â†’ ç”¨æˆ·ç»§ç»­è¾“å…¥...ï¼ˆé‡å¤ä¸Šè¿°æµç¨‹ï¼‰
    â”‚
    â”œâ”€â†’ å½“ is_complete = true
    â”‚       â””â”€â†’ å‰ç«¯å‘é€ï¼š__GENERATE_PLAN__ æ¶ˆæ¯
    â”‚
    â”œâ”€â†’ åç«¯ï¼šè¡Œç¨‹ç”ŸæˆLLMï¼ˆé˜¶æ®µ2ï¼‰
    â”‚       â”œâ”€â†’ éªŒè¯å¿…å¡«å­—æ®µ
    â”‚       â”œâ”€â†’ æç¤ºè¯æ³¨å…¥å®Œæ•´éœ€æ±‚
    â”‚       â”œâ”€â†’ LLM ç”Ÿæˆè¯¦ç»†è¡Œç¨‹ï¼ˆå« city å­—æ®µï¼‰
    â”‚       â””â”€â†’ è¿”å›ï¼šdaily_plan_json + plan + itinerary
    â”‚
    â”œâ”€â†’ å‰ç«¯ï¼šæ¸²æŸ“è¡Œç¨‹
    â”‚       â”œâ”€â†’ buildDailyPlanHtml()
    â”‚       â”œâ”€â†’ æ’å…¥åœ°å›¾å®¹å™¨
    â”‚       â”œâ”€â†’ æ’å…¥è·¯çº¿æŒ‰é’®
    â”‚       â””â”€â†’ æ˜¾ç¤ºæ¶ˆæ¯
    â”‚
    â”œâ”€â†’ å‰ç«¯ï¼šå¼‚æ­¥æ¸²æŸ“åœ°å›¾
    â”‚       â”œâ”€â†’ renderTravelMap(itinerary, city)
    â”‚       â”‚   â”œâ”€â†’ æ‰¹é‡åœ°ç†ç¼–ç ï¼ˆ/api/batch-geocodeï¼‰
    â”‚       â”‚   â”œâ”€â†’ åˆå§‹åŒ–é«˜å¾·åœ°å›¾
    â”‚       â”‚   â”œâ”€â†’ æ·»åŠ æ ‡è®°å’Œè·¯çº¿
    â”‚       â”‚   â””â”€â†’ ç¼“å­˜ mapData åˆ°æ¶ˆæ¯
    â”‚       â”‚
    â”‚       â””â”€â†’ è¿”å› coordsMap
    â”‚
    â””â”€â†’ å‰ç«¯ï¼šå¼‚æ­¥å¡«å……è·¯çº¿
            â””â”€â†’ populateRoutesForMessage(city, coordsMap)
                â”œâ”€â†’ éå†æ‰€æœ‰è·¯çº¿æŒ‰é’®
                â”œâ”€â†’ æ£€æŸ¥ä¸‰çº§ç¼“å­˜ï¼š
                â”‚   â”œâ”€â†’ 1. æ¶ˆæ¯çº§ç¼“å­˜ï¼ˆroutesDataï¼‰
                â”‚   â”œâ”€â†’ 2. LocalStorage ç¼“å­˜
                â”‚   â””â”€â†’ 3. API è°ƒç”¨ï¼ˆ/api/multi-mode-routeï¼‰
                â”‚
                â”œâ”€â†’ è·å–ä¸‰ç§æ¨¡å¼æ•°æ®ï¼ˆdriving, walking, transitï¼‰
                â”œâ”€â†’ updateRouteDisplay()ï¼šæ›´æ–°UI
                â””â”€â†’ ä¿å­˜åˆ°ç¼“å­˜
```

### 2. åœ°å›¾æ¸²æŸ“æµç¨‹

```
renderTravelMap()
    â”‚
    â”œâ”€â†’ 1. æå–æ‰€æœ‰æ™¯ç‚¹åç§°
    â”‚       itinerary.flatMap(day => day.activities.map(a => a.name))
    â”‚
    â”œâ”€â†’ 2. æ‰¹é‡åœ°ç†ç¼–ç 
    â”‚       POST /api/batch-geocode
    â”‚       {places: ["å¤–æ»©", "å—äº¬è·¯", ...], city: "ä¸Šæµ·"}
    â”‚           â”‚
    â”‚           â””â”€â†’ åç«¯ï¼šå¾ªç¯è°ƒç”¨ _amap_geocode_sync()
    â”‚                   â””â”€â†’ è¿”å›ï¼š[{name, coords, success}, ...]
    â”‚
    â”œâ”€â†’ 3. æ„å»ºåæ ‡æ˜ å°„
    â”‚       coordsMap = new Map<string, [lng, lat]>()
    â”‚
    â”œâ”€â†’ 4. åˆå§‹åŒ–åœ°å›¾
    â”‚       new AMap.Map(mapId, {zoom: 13, center: firstCoords})
    â”‚
    â”œâ”€â†’ 5. é€å¤©ç»˜åˆ¶
    â”‚       for each day:
    â”‚           â”œâ”€â†’ é€‰æ‹©é¢œè‰²ï¼šDAILY_COLORS[dayIdx]
    â”‚           â”œâ”€â†’ æ·»åŠ æ ‡è®°ï¼š
    â”‚           â”‚       for each activity:
    â”‚           â”‚           new AMap.Marker({
    â”‚           â”‚               position: coords,
    â”‚           â”‚               label: `D${day.day}-${actIdx+1}`
    â”‚           â”‚           })
    â”‚           â”‚
    â”‚           â””â”€â†’ ç»˜åˆ¶è·¯çº¿ï¼š
    â”‚                   new AMap.Polyline({
    â”‚                       path: dayCoords,
    â”‚                       strokeColor: color,
    â”‚                       strokeWeight: 4
    â”‚                   })
    â”‚
    â””â”€â†’ 6. ç¼“å­˜åœ°å›¾æ•°æ®
            messages.value[msgIndex].mapData = {
                itinerary, city, coordsMap, mapId
            }
            saveCurrentSession()
```

### 3. è·¯çº¿æŸ¥è¯¢æµç¨‹

```
populateRoutesForMessage(city, coordsMap)
    â”‚
    â”œâ”€â†’ éå†æ‰€æœ‰ .route-chip å…ƒç´ 
    â”‚       for each chip:
    â”‚           origin = chip.getAttribute('data-origin')
    â”‚           destination = chip.getAttribute('data-destination')
    â”‚           routeKey = `${origin}->${destination}`
    â”‚
    â”œâ”€â†’ ä¸‰çº§ç¼“å­˜æ£€æŸ¥
    â”‚       â”‚
    â”‚       â”œâ”€â†’ Level 1: æ¶ˆæ¯çº§ç¼“å­˜
    â”‚       â”‚       if (messageRoutesCache[routeKey]) {
    â”‚       â”‚           updateRouteDisplay(cachedData)
    â”‚       â”‚           continue
    â”‚       â”‚       }
    â”‚       â”‚
    â”‚       â”œâ”€â†’ Level 2: LocalStorage ç¼“å­˜
    â”‚       â”‚       cachedRoutes = getMultiModeRouteFromCache(city, origin, dest)
    â”‚       â”‚       if (cachedRoutes) {
    â”‚       â”‚           messageRoutesCache[routeKey] = cachedRoutes
    â”‚       â”‚           updateRouteDisplay(cachedRoutes)
    â”‚       â”‚           continue
    â”‚       â”‚       }
    â”‚       â”‚
    â”‚       â””â”€â†’ Level 3: API è°ƒç”¨
    â”‚               if (coordsMap.has(origin) && coordsMap.has(dest)) {
    â”‚                   POST /api/multi-mode-route
    â”‚                   {
    â”‚                       origin_coords, destination_coords, city
    â”‚                   }
    â”‚                       â”‚
    â”‚                       â””â”€â†’ åç«¯ï¼šå¹¶è¡ŒæŸ¥è¯¢ä¸‰ç§æ¨¡å¼
    â”‚                               â”œâ”€â†’ driving = _amap_direction_sync(..., "driving")
    â”‚                               â”œâ”€â†’ walking = _amap_direction_sync(..., "walking")
    â”‚                               â””â”€â†’ transit = _amap_direction_sync(..., "transit", city)
    â”‚                                   
    â”‚                                   è¿”å›ï¼š{
    â”‚                                       routes: {
    â”‚                                           driving: {distance_km, duration_min, steps},
    â”‚                                           walking: {...},
    â”‚                                           transit: {...}
    â”‚                                       }
    â”‚                                   }
    â”‚               
    â”‚                   â”œâ”€â†’ ä¿å­˜åˆ° LocalStorage
    â”‚                   â”œâ”€â†’ ä¿å­˜åˆ°æ¶ˆæ¯çº§ç¼“å­˜
    â”‚                   â””â”€â†’ updateRouteDisplay()
    â”‚               }
    â”‚
    â””â”€â†’ saveCurrentSession()
```

### 4. é…’åº—æ¨èæµç¨‹

```
ç”¨æˆ·è¾“å…¥ "æˆ‘æƒ³è®¢é…’åº—"
    â”‚
    â”œâ”€â†’ å‰ç«¯ï¼šPOST /api/hotel-chat (SSEæµå¼)
    â”‚       Body: {message: "...", travel_plan: {...}}
    â”‚
    â”œâ”€â†’ åç«¯ï¼šæ­¥éª¤1 - æ„å›¾åˆ†æ
    â”‚       â”œâ”€â†’ hotel_agent.analyze_intent()
    â”‚       â”œâ”€â†’ LLM åˆ†æç”¨æˆ·æ„å›¾å’Œå‚æ•°
    â”‚       â”œâ”€â†’ æå–ï¼šdestination, checkin_date, checkout_date ç­‰
    â”‚       â””â”€â†’ SSE å‘é€ï¼š{step: 1, status: 'completed', data: {...}}
    â”‚
    â”œâ”€â†’ åç«¯ï¼šæ­¥éª¤2 - å‚æ•°éªŒè¯
    â”‚       â”œâ”€â†’ æ£€æŸ¥å¿…å¡«å­—æ®µï¼ˆdestinationï¼‰
    â”‚       â””â”€â†’ SSE å‘é€ï¼š{step: 2, status: 'completed'}
    â”‚
    â”œâ”€â†’ åç«¯ï¼šæ­¥éª¤3 - é…’åº—æœç´¢
    â”‚       â”œâ”€â†’ booking_hotel_search.search_hotel()
    â”‚       â”‚   â”œâ”€â†’ Playwright æ‰“å¼€ Booking.com
    â”‚       â”‚   â”œâ”€â†’ è¾“å…¥æœç´¢æ¡ä»¶
    â”‚       â”‚   â”œâ”€â†’ æå–é…’åº—ä¿¡æ¯ï¼š
    â”‚       â”‚   â”‚   â€¢ nameï¼ˆåç§°ï¼‰
    â”‚       â”‚   â”‚   â€¢ urlï¼ˆé¢„è®¢é¡µé¢URLï¼‰ğŸ†•
    â”‚       â”‚   â”‚   â€¢ imageï¼ˆé…’åº—å›¾ç‰‡URLï¼‰ğŸ†•
    â”‚       â”‚   â”‚   â€¢ priceï¼ˆä»·æ ¼ï¼‰
    â”‚       â”‚   â”‚   â€¢ scoreï¼ˆè¯„åˆ†ï¼‰
    â”‚       â”‚   â”‚   â€¢ locationï¼ˆä½ç½®ï¼‰
    â”‚       â”‚   â”‚   â€¢ facilitiesï¼ˆè®¾æ–½ï¼‰
    â”‚       â”‚   â””â”€â†’ è¿”å›å‰10å®¶é…’åº—
    â”‚       â””â”€â†’ SSE å‘é€ï¼š{step: 3, status: 'completed', message: 'æ‰¾åˆ° N å®¶é…’åº—'}
    â”‚
    â”œâ”€â†’ åç«¯ï¼šæ­¥éª¤4 - ç”Ÿæˆæ¨èï¼ˆæµå¼ï¼‰
    â”‚       â”œâ”€â†’ SSE å‘é€ï¼š{type: 'recommendation_start'}
    â”‚       â”œâ”€â†’ hotel_agent.generate_recommendations()
    â”‚       â”‚   â”œâ”€â†’ LLM ç”Ÿæˆæ¨èæ–‡æœ¬
    â”‚       â”‚   â”œâ”€â†’ åœ¨æ¨èç†ç”±åæ’å…¥å ä½ç¬¦ [HOTEL_CARD:X] ğŸ†•
    â”‚       â”‚   â””â”€â†’ æµå¼è¾“å‡ºæ–‡æœ¬ç‰‡æ®µ
    â”‚       â”œâ”€â†’ SSE å‘é€ï¼š{type: 'recommendation_chunk', content: "..."}
    â”‚       â”œâ”€â†’ SSE å‘é€ï¼š{type: 'recommendation_end'}
    â”‚       â””â”€â†’ SSE å‘é€ï¼š{type: 'hotels_data', hotels: [...]} ğŸ†•
    â”‚
    â””â”€â†’ å‰ç«¯ï¼šè§£æå’Œæ¸²æŸ“
            â”œâ”€â†’ æ¥æ”¶æ¨èæ–‡æœ¬æµ
            â”œâ”€â†’ æ¥æ”¶é…’åº—æ•°æ®ï¼ˆhotels_dataï¼‰
            â”œâ”€â†’ parseTextWithHotelCards() è§£æå ä½ç¬¦ ğŸ†•
            â”‚   â”œâ”€â†’ åŒ¹é… [HOTEL_CARD:0], [HOTEL_CARD:1] ç­‰
            â”‚   â””â”€â†’ åˆ†å‰²ä¸ºæ–‡æœ¬æ®µå’Œé…’åº—æ®µ
            â””â”€â†’ æ¸²æŸ“ï¼š
                â”œâ”€â†’ æ–‡æœ¬æ®µï¼šMarkdown æ¸²æŸ“
                â””â”€â†’ é…’åº—æ®µï¼šæ˜¾ç¤ºé…’åº—å¡ç‰‡
                    â”œâ”€â†’ é…’åº—å›¾ç‰‡
                    â”œâ”€â†’ é…’åº—åç§°ã€ä»·æ ¼ã€è¯„åˆ†
                    â””â”€â†’ é¢„è®¢é“¾æ¥ï¼ˆè·³è½¬åˆ° Booking.comï¼‰
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. å‰ç«¯ä¼˜åŒ–

#### æ‰¹é‡åœ°ç†ç¼–ç 
- **é—®é¢˜**ï¼šé€ä¸ªæŸ¥è¯¢æ™¯ç‚¹åæ ‡ä¼šå¯¼è‡´å¤§é‡ä¸²è¡Œè¯·æ±‚
- **æ–¹æ¡ˆ**ï¼šåˆ›å»º `/api/batch-geocode` æ¥å£ï¼Œä¸€æ¬¡æ€§è¿”å›æ‰€æœ‰åæ ‡
- **æ•ˆæœ**ï¼š10ä¸ªæ™¯ç‚¹ä» 10 æ¬¡è¯·æ±‚é™è‡³ 1 æ¬¡ï¼Œè€—æ—¶å‡å°‘ 90%

#### ä¸‰çº§è·¯çº¿ç¼“å­˜
```typescript
// Level 1: æ¶ˆæ¯çº§ï¼ˆå†…å­˜ï¼‰- æœ€å¿«
messageRoutesCache[routeKey] = routesData

// Level 2: LocalStorageï¼ˆæŒä¹…åŒ–ï¼‰- è·¨ä¼šè¯
localStorage.setItem(ROUTE_CACHE_KEY, JSON.stringify(cache))

// Level 3: API è°ƒç”¨ - ä»…åœ¨ç¼“å­˜æœªå‘½ä¸­æ—¶
fetch('/api/multi-mode-route', ...)
```

#### åœ°å›¾æ•°æ®æŒä¹…åŒ–
- **é—®é¢˜**ï¼šåˆ·æ–°é¡µé¢ååœ°å›¾æ¶ˆå¤±
- **æ–¹æ¡ˆ**ï¼šå°† `itinerary`ã€`city`ã€`coordsMap`ã€`mapId` ä¿å­˜åˆ°æ¶ˆæ¯å¯¹è±¡
- **å®ç°**ï¼š`rerenderCachedMaps()` åœ¨åŠ è½½ä¼šè¯æ—¶é‡æ–°åˆå§‹åŒ–åœ°å›¾
- **æ•ˆæœ**ï¼šæ— éœ€é‡æ–°åœ°ç†ç¼–ç å’Œ API è°ƒç”¨

#### å¼‚æ­¥æ¸²æŸ“
```typescript
// åœ°å›¾æ¸²æŸ“å’Œè·¯çº¿æŸ¥è¯¢å¹¶è¡Œæ‰§è¡Œï¼Œäº’ä¸é˜»å¡
renderTravelMap(msgIndex, itinerary, city).then(coordsMap => {
  return populateRoutesForMessage(msgIndex, city, coordsMap)
})
```

### 2. åç«¯ä¼˜åŒ–

#### JSON è§£æå¥å£®æ€§
- **é—®é¢˜**ï¼šLLM å¯èƒ½è¿”å›å¸¦å‰åç¼€çš„ JSON
- **æ–¹æ¡ˆ**ï¼š
  1. ç›´æ¥è§£æ
  2. æ ˆåŒ¹é…æå–ï¼ˆæ”¯æŒåµŒå¥—æ•°ç»„/å¯¹è±¡ï¼‰
  3. æ•´ä½“æ–‡æœ¬è§£æ
  4. é™çº§ä¸ºèŠå¤©æ¨¡å¼

#### å¹¶è¡Œè·¯çº¿æŸ¥è¯¢
```python
@app.post("/api/multi-mode-route")
async def multi_mode_route(req: MultiModeRouteRequest):
    loop = asyncio.get_event_loop()
    
    def compute():
        # å¹¶è¡ŒæŸ¥è¯¢ä¸‰ç§æ¨¡å¼ï¼ˆåç«¯åŒæ­¥ï¼Œå‰ç«¯å¼‚æ­¥ï¼‰
        driving = _amap_direction_sync(..., "driving")
        walking = _amap_direction_sync(..., "walking")
        transit = _amap_direction_sync(..., "transit", city)
        return {"routes": {driving, walking, transit}}
    
    result = await loop.run_in_executor(None, compute)
    return result
```

#### ä¼šè¯çº§è‰ç¨¿éš”ç¦»
- **é—®é¢˜**ï¼šå¤šä¼šè¯å…±äº«è‰ç¨¿å¯¼è‡´æ•°æ®æ··ä¹±
- **æ–¹æ¡ˆ**ï¼šå°† `draft` ç›´æ¥å­˜å‚¨åœ¨ `ChatSession` å¯¹è±¡ä¸­
- **æ•ˆæœ**ï¼šåˆ‡æ¢ä¼šè¯æ—¶è‡ªåŠ¨åŠ è½½å¯¹åº”è‰ç¨¿ï¼Œå®Œå…¨éš”ç¦»

---

## è®¾è®¡æ¨¡å¼

### 1. ç»„åˆå¼ APIï¼ˆComposition APIï¼‰
ä½¿ç”¨ Vue 3 çš„ `setup()` å’Œ Composition APIï¼Œæå‡ä»£ç å¤ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

```typescript
// é€»è¾‘å°è£…ç¤ºä¾‹
function useTravelDraft() {
  const draft = ref<TravelPlanDraft | null>(null)
  
  const initDraft = () => { /* ... */ }
  const updateDraft = (updates: any) => { /* ... */ }
  const resetDraft = () => { /* ... */ }
  
  return { draft, initDraft, updateDraft, resetDraft }
}
```

### 2. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰
ä¸åŒå‡ºè¡Œæ¨¡å¼ï¼ˆé©¾è½¦ã€æ­¥è¡Œã€å…¬äº¤ï¼‰ä½¿ç”¨ç»Ÿä¸€æ¥å£ï¼ŒåŠ¨æ€é€‰æ‹©ç­–ç•¥ã€‚

```python
def _amap_direction_sync(origin, dest, mode: str, city: str = None):
    if mode == "walking":
        path = "/v3/direction/walking"
    elif mode == "transit":
        path = "/v3/direction/transit/integrated"
    else:
        path = "/v3/direction/driving"
    # ç»Ÿä¸€å¤„ç†é€»è¾‘
```

### 3. è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰
Vue çš„å“åº”å¼ç³»ç»Ÿæœ¬è´¨ä¸Šæ˜¯è§‚å¯Ÿè€…æ¨¡å¼ï¼ŒçŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘UIæ›´æ–°ã€‚

```typescript
// æ•°æ®å˜åŒ– â†’ è‡ªåŠ¨è§¦å‘UIæ›´æ–°
const draftCompleteness = computed(() => {
  // è‡ªåŠ¨ç›‘å¬ travelPlanDraft å˜åŒ–
  const filled = Object.values(travelPlanDraft.value || {}).filter(Boolean).length
  return Math.round((filled / 4) * 100)
})
```

### 4. å•ä¾‹æ¨¡å¼ï¼ˆSingleton Patternï¼‰
ä¼šè¯ç®¡ç†ã€ç¼“å­˜ç®¡ç†ç­‰å…¨å±€çŠ¶æ€ä½¿ç”¨å•ä¾‹æ¨¡å¼ã€‚

```typescript
// LocalStorage ç¼“å­˜å•ä¾‹
const SESSIONS_STORAGE_KEY = 'chat_sessions_v2'
const ROUTE_CACHE_KEY = 'route_cache_v2'

function loadSessions(): ChatSession[] {
  const stored = localStorage.getItem(SESSIONS_STORAGE_KEY)
  return stored ? JSON.parse(stored) : []
}
```

### 5. å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰
æ¶ˆæ¯å¯¹è±¡ã€ä¼šè¯å¯¹è±¡çš„åˆ›å»ºä½¿ç”¨å·¥å‚å‡½æ•°ã€‚

```typescript
function createMessage(role: 'user' | 'assistant', content: string): Message {
  return {
    role,
    content: [{ type: 'text', text: content }],
    mapData: undefined,
    routesData: undefined
  }
}

function createChatSession(title: string = 'æ–°å¯¹è¯'): ChatSession {
  return {
    id: generateId(),
    title,
    messages: [],
    draft: null,
    createdAt: Date.now()
  }
}
```

### 6. è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰
ä¸‰çº§ç¼“å­˜æ£€æŸ¥ã€JSON è§£æå›é€€æœºåˆ¶éƒ½ä½“ç°äº†è´£ä»»é“¾æ¨¡å¼ã€‚

```typescript
// ç¼“å­˜è´£ä»»é“¾
if (messageCache[key]) return messageCache[key]
if (localStorageCache[key]) return localStorageCache[key]
return await fetchFromAPI(key)
```

---

## å®‰å…¨æ€§è€ƒè™‘

### 1. XSS é˜²æŠ¤
```typescript
import DOMPurify from 'dompurify'

// Markdown æ¸²æŸ“å‰æ¸…æ´ HTML
const cleanHtml = DOMPurify.sanitize(marked.parse(content))
```

### 2. API å¯†é’¥ä¿æŠ¤
```bash
# .env æ–‡ä»¶åŠ å…¥ .gitignore
ARK_API_KEY=xxx
AMAP_KEY=xxx
```

### 3. CORS é…ç½®
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],  # ä»…å…è®¸å‰ç«¯åŸŸå
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)
```

### 4. è¾“å…¥éªŒè¯
```python
from pydantic import BaseModel

class ChatRequest(BaseModel):
    messages: List[ChatMessage]
    model: str = "doubao-1-5-thinking-vision-pro-250428"
    travel_draft: Optional[TravelPlanDraft] = None
```

---

## æ‰©å±•æ€§è®¾è®¡

### 1. å¤šåœ°å›¾æœåŠ¡æ”¯æŒ
å½“å‰ä½¿ç”¨é«˜å¾·åœ°å›¾ï¼Œæœªæ¥å¯è½»æ¾åˆ‡æ¢ï¼š

```typescript
interface MapProvider {
  initMap(id: string, options: any): any
  addMarker(options: any): any
  addPolyline(options: any): any
  geocode(place: string, city?: string): Promise<[number, number]>
}

class AmapProvider implements MapProvider { /* ... */ }
class BaiduMapProvider implements MapProvider { /* ... */ }
```

### 2. LLM æ¨¡å‹åˆ‡æ¢
ä½¿ç”¨ OpenAI SDK å…¼å®¹æ ¼å¼ï¼Œå¯å¿«é€Ÿåˆ‡æ¢æ¨¡å‹ï¼š

```python
# åªéœ€ä¿®æ”¹ base_url å’Œ model å‚æ•°
client = openai.OpenAI(
    api_key=os.environ.get("ARK_API_KEY"),
    base_url="https://ark.cn-beijing.volces.com/api/v3"  # æˆ–å…¶ä»–å…¼å®¹æ¥å£
)
```

### 3. æ’ä»¶åŒ–è·¯ç”±è§„åˆ’
```python
class RoutePlugin:
    def plan(self, origin, dest, mode, city): pass

class AmapRoutePlugin(RoutePlugin): pass
class BaiduRoutePlugin(RoutePlugin): pass
```

---

## æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹

1. **åŒé˜¶æ®µ LLM æ¶æ„**ï¼šéœ€æ±‚åˆ†æ + è¡Œç¨‹ç”Ÿæˆï¼Œæµç¨‹æ¸…æ™°ï¼Œç”¨æˆ·ä½“éªŒä¼˜ç§€
2. **ä¸‰çº§ç¼“å­˜ç³»ç»Ÿ**ï¼šæ¶ˆæ¯çº§ + LocalStorage + APIï¼Œæè‡´æ€§èƒ½ä¼˜åŒ–
3. **ä¼šè¯çº§æ•°æ®éš”ç¦»**ï¼šå®Œå…¨ç‹¬ç«‹çš„å¤šä¼šè¯ç®¡ç†
4. **å¼‚æ­¥å¹¶è¡Œæ¸²æŸ“**ï¼šåœ°å›¾ã€è·¯çº¿äº’ä¸é˜»å¡ï¼Œå“åº”è¿…é€Ÿ
5. **å¥å£®çš„ JSON è§£æ**ï¼šæ ˆåŒ¹é… + å¤šå±‚å›é€€ï¼Œå®¹é”™æ€§å¼º
6. **äº¤äº’å¼è·¯çº¿å±•ç¤º**ï¼šGoogle é£æ ¼ï¼Œä¸‰ç§æ¨¡å¼æ— ç¼åˆ‡æ¢

### æŠ€æœ¯æ ˆä¼˜åŠ¿

- **Vue 3 Composition API**ï¼šä»£ç ç»„ç»‡æ¸…æ™°ï¼Œé€»è¾‘å¤ç”¨ç®€å•
- **FastAPI**ï¼šé«˜æ€§èƒ½ã€è‡ªåŠ¨æ–‡æ¡£ã€ç±»å‹å®‰å…¨
- **é«˜å¾·åœ°å›¾**ï¼šå›½å†…è®¿é—®ç¨³å®šï¼ŒAPI ä¸°å¯Œ
- **è±†åŒ… AI**ï¼šæ¨ç†èƒ½åŠ›å¼ºï¼Œæ”¯æŒç»“æ„åŒ–è¾“å‡º

### æœªæ¥ä¼˜åŒ–æ–¹å‘

1. **æ€§èƒ½ç›‘æ§**ï¼šæ·»åŠ åŸ‹ç‚¹ï¼Œåˆ†æç”¨æˆ·è¡Œä¸ºå’Œæ€§èƒ½ç“¶é¢ˆ
2. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„å¼‚å¸¸æ•è·å’Œç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
3. **æµ‹è¯•è¦†ç›–**ï¼šå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2E æµ‹è¯•
4. **äº‘ç«¯åŒæ­¥**ï¼šè´¦å·ç³»ç»Ÿ + æ•°æ®åº“ï¼Œæ”¯æŒè·¨è®¾å¤‡è®¿é—®
5. **å›½é™…åŒ–**ï¼šå¤šè¯­è¨€æ”¯æŒï¼Œæ‰©å±•æµ·å¤–å¸‚åœº

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.1  
**æœ€åæ›´æ–°**ï¼š2025-11-17  
**ç»´æŠ¤è€…**ï¼šAI æ—…è¡ŒåŠ©æ‰‹å›¢é˜Ÿ

### æ›´æ–°æ—¥å¿—

#### v1.1 (2025-11-17)
- ğŸ†• é…’åº—æ¨èåŠŸèƒ½å¢å¼ºï¼š
  - æ·»åŠ é…’åº—é¢„è®¢é¡µé¢URLæå–ï¼ˆPlaywright è‡ªåŠ¨åŒ–ï¼‰
  - æ·»åŠ é…’åº—å›¾ç‰‡URLæå–
  - å®ç°é…’åº—å¡ç‰‡åµŒå…¥åˆ°æ¨èæ–‡æœ¬ä¸­ï¼ˆå ä½ç¬¦æœºåˆ¶ï¼‰
  - æ”¯æŒä»æ—…è¡Œè®¡åˆ’ä¸­æå–é…’åº—éœ€æ±‚ä¿¡æ¯
- ğŸ†• å‰ç«¯ç±»å‹å®‰å…¨ä¼˜åŒ–ï¼š
  - ä½¿ç”¨ TypeScript è”åˆç±»å‹å’Œç±»å‹å®ˆå«
  - ä¼˜åŒ–é…’åº—å¡ç‰‡æ¸²æŸ“é€»è¾‘
- ğŸ†• ç”¨æˆ·ä½“éªŒä¼˜åŒ–ï¼š
  - ç§»é™¤æ­¥éª¤ä¸­JSONæ•°æ®çš„æ˜¾ç¤ºï¼Œç•Œé¢æ›´ç®€æ´
  - é…’åº—å¡ç‰‡å“åº”å¼è®¾è®¡ï¼Œé€‚é…ç§»åŠ¨ç«¯

