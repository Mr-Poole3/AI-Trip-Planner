# 用户系统设计方案（AI-Trip-Planner Backend）

## 1. 设计目标与约束

- 支持基础用户体系：
  - 用户注册
  - 用户登录 / 退出
  - 忘记密码（通过邮箱重置）
- 支持安全鉴权：
  - Access Token + Refresh Token 机制
  - 基于 Token 的接口鉴权中间件
- MySQL 数据存储：
  - 用户信息表
  - 登录会话 / 刷新令牌表（可选）
  - LLM 调用历史表（关联到用户）
- 安全性要求：
  - 密码强度校验
  - 密码加盐哈希存储（如 bcrypt / argon2）
  - Token 过期与刷新机制
  - 防止暴力破解（登录失败计数 + 风控）
- 可扩展性：
  - 后续可扩展第三方登录（微信、Google 等）
  - 可扩展更多用户属性 / 权限体系

> 说明：本方案尽量和具体框架解耦，只约定 RESTful 风格接口与 MySQL 表结构，方便在现有 `backend` 中落地实现。

---

## 2. API 设计总览

接口统一假设前缀为：`/api/v1`

### 2.1 鉴权与用户相关接口

1. `POST /api/v1/auth/register` 用户注册（支持用户名、验证码、确认密码）  
2. `POST /api/v1/auth/login` 用户登录  
3. `POST /api/v1/auth/logout` 用户退出  
4. `POST /api/v1/auth/refresh` 刷新 Access Token  
5. `GET  /api/v1/auth/me` 获取当前登录用户信息  
6. `POST /api/v1/auth/forgot-password` 申请重置密码  
7. `POST /api/v1/auth/reset-password` 提交新密码  
8. `POST /api/v1/auth/change-password` 登录状态下修改密码  
9. `POST /api/v1/auth/oauth/google` Google 第三方登录/注册  

### 2.2 LLM 调用历史接口

1. `GET  /api/v1/llm/history` 获取当前用户 LLM 调用历史列表（分页）  
2. `GET  /api/v1/llm/history/{id}` 获取单条调用详情  
3. `DELETE /api/v1/llm/history/{id}` 删除单条调用记录（软删除）  
4. 业务内部接口：在调用 LLM 时自动写入历史记录（service 级逻辑）

---

## 3. 接口详细设计

### 3.1 公共约定

- 所有请求和响应使用 `application/json`。
- 时间字段使用 ISO8601 字符串（例如 `2025-12-25T12:00:00Z`）或统一为 UTC 时间戳。
- 登录后接口需在 Header 中携带：
  - `Authorization: Bearer <access_token>`

#### 3.1.1 通用响应结构

```jsonc
{
  "code": 0,
  "message": "ok",
  "data": {}
}
```

- `code = 0` 表示成功；非 0 表示各种业务错误。
- 典型错误码示例：
  - `1001` 参数校验失败
  - `1002` 未授权 / Token 无效
  - `1003` Token 过期
  - `1004` 用户不存在或密码错误
  - `1005` Token 刷新失败
  - `2001` 邮箱已注册
  - `3001` 密码重置 token 无效或过期

---

### 3.2 注册接口

**接口**  
`POST /api/v1/auth/register`

**请求体**

```json
{
  "username": "xiaoming",
  "email": "user@example.com",
  "password": "P@ssw0rd123",
  "confirm_password": "P@ssw0rd123",
  "captcha": "1234"
}
```

**请求校验**

- `username` 必填，唯一，建议长度 4-32
- `email` 必填，唯一，格式校验
- `password` 必填，长度至少 8，至少包含数字与字母
- `confirm_password` 必填，需与 `password` 一致
- `captcha` 必填，需与后端缓存/Session中存储的验证码一致

**响应**

成功时：

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "user_id": 1
  }
}
```

失败示例（验证码错误）：

```json
{
  "code": 1006,
  "message": "invalid captcha",
  "data": {}
}
```

**核心逻辑**

- 验证 `captcha` 是否正确且未过期。
- 校验 `password` 与 `confirm_password` 是否一致。
- 检查 `users` 表中是否存在相同 `username` 或 `email`。
- 使用安全算法对密码进行加盐哈希（例如 bcrypt）。
- 写入 `users` 表。

---

### 3.3 登录接口

**接口**  
`POST /api/v1/auth/login`

**请求体**

```json
{
  "email": "user@example.com",
  "password": "P@ssw0rd123"
}
```

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "access_token": "<jwt_access_token>",
    "refresh_token": "<jwt_refresh_token>",
    "token_type": "Bearer",
    "expires_in": 3600,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "nickname": "小明",
      "avatar_url": null
    }
  }
}
```

**核心逻辑**

- 根据 `email` 查询用户，检查是否存在、状态是否正常（未禁用）。
- 使用相同算法验证密码哈希。
- 登录失败计数与风控（可在 `users` 或 `user_login_log` 中记录）。
- 生成：
  - `access_token`：有效期较短，例如 1 小时。
  - `refresh_token`：有效期较长，例如 30 天。
- 可选：在 `user_tokens` 表记录 refresh token，用于后续失效。

---

### 3.4 刷新 Token

**接口**  
`POST /api/v1/auth/refresh`

**请求体**

```json
{
  "refresh_token": "<jwt_refresh_token>"
}
```

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "access_token": "<new_access_token>",
    "refresh_token": "<new_refresh_token>",
    "token_type": "Bearer",
    "expires_in": 3600
  }
}
```

**核心逻辑**

- 验证 `refresh_token` 的合法性与有效期。
- 如果使用数据库存储 refresh token：
  - 检查 token 是否存在、未过期、未被标记为已注销。
- 生成新的 `access_token`（可选是否同时滚动更新 `refresh_token`）。
- 旧的 `refresh_token` 可视安全策略决定是否失效。

---

### 3.5 退出登录

**接口**  
`POST /api/v1/auth/logout`

**请求体**

```json
{
  "refresh_token": "<jwt_refresh_token>"
}
```

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {}
}
```

**核心逻辑**

- 如果使用数据库维护 `user_tokens`：
  - 将对应 `refresh_token` 标记为失效 / 删除。
- 可选：将对应的 `jti`（token id）加入黑名单（如实现黑名单机制）。

---

### 3.6 获取当前用户信息

**接口**  
`GET /api/v1/auth/me`

**请求头**

- `Authorization: Bearer <access_token>`

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "id": 1,
    "email": "user@example.com",
    "nickname": "小明",
    "avatar_url": null,
    "phone": "13800000000",
    "created_at": "2025-01-01T12:00:00Z"
  }
}
```

**核心逻辑**

- 通过中间件解析 `access_token`，提取 `user_id`。
- 根据 `user_id` 查询 `users` 表返回基础资料。

---

### 3.7 忘记密码：申请重置

**接口**  
`POST /api/v1/auth/forgot-password`

**请求体**

```json
{
  "email": "user@example.com"
}
```

**响应**

```json
{
  "code": 0,
  "message": "if email exists, reset link sent",
  "data": {}
}
```

**安全设计**

- 即使邮箱不存在，也返回相同的响应，避免探测用户是否存在。

**核心逻辑**

- 如果找到用户：
  - 生成一个一次性 `reset_token`（随机字符串 + 过期时间，例如 30 分钟）。
  - 写入 `password_reset_tokens` 表。
  - 向用户邮箱发送重置链接，例如：
    - `https://frontend-domain/reset-password?token=<reset_token>`
- 如果未找到用户：
  - 不暴露此信息，仍然返回成功响应。

---

### 3.8 忘记密码：重置密码

**接口**  
`POST /api/v1/auth/reset-password`

**请求体**

```json
{
  "reset_token": "<reset_token>",
  "new_password": "NewP@ssw0rd123"
}
```

**响应**

```json
{
  "code": 0,
  "message": "password reset success",
  "data": {}
}
```

**核心逻辑**

- 根据 `reset_token` 查询 `password_reset_tokens` 表：
  - 检查是否存在、未过期、未使用。
- 获取关联的 `user_id`，将新密码进行哈希并更新到 `users` 表。
- 将该 `reset_token` 标记为已使用。
- 可选：失效该用户所有 `refresh_token`，要求重新登录。

---

### 3.9 修改密码（已登录）

**接口**  
`POST /api/v1/auth/change-password`

**请求头**

- `Authorization: Bearer <access_token>`

**请求体**

```json
{
  "old_password": "P@ssw0rd123",
  "new_password": "NewP@ssw0rd123"
}
```

**响应**

```json
{
  "code": 0,
  "message": "password changed",
  "data": {}
}
```

**核心逻辑**

- 使用 `access_token` 获取 `user_id`。
- 校验 `old_password` 是否正确。
- 校验新密码强度。
- 更新 `users.password_hash`。
- 可选：失效所有其他会话 / refresh token。

---

### 3.10 第三方登录（以 Google 为例）

**接口**  
`POST /api/v1/auth/oauth/google`

**请求体**

```json
{
  "id_token": "<google_id_token>"
}
```

**核心逻辑**

- 后端校验 `id_token` 的有效性（调用 Google API 或校验签名）。
- 提取 Google 返回的 `email` 和 `name`（作为默认 `username`）。
- 检查 `users` 表：
  - 如果 `oauth_provider='google'` 且 `oauth_id` 匹配，则直接登录并返回 Token。
  - 如果 `email` 已存在但 `oauth_provider` 不同，可选择合并账号或提示错误。
  - 如果都不存在，则自动创建新用户（`password_hash` 为空），设置 `oauth_provider` 和 `oauth_id`。
- 返回登录成功的 Access Token 和用户信息。

---

## 4. LLM 调用历史接口设计

### 4.1 获取调用历史列表

**接口**  
`GET /api/v1/llm/history`

**查询参数**

- `page` 页码，默认 1
- `page_size` 每页条数，默认 20，最大 100

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "page": 1,
    "page_size": 20,
    "total": 123,
    "items": [
      {
        "id": 1001,
        "model": "doubao-lite",
        "created_at": "2025-01-01T12:00:00Z"
      }
    ]
  }
}
```

---

### 4.2 获取单条调用详情

**接口**  
`GET /api/v1/llm/history/{id}`

**响应**

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "id": 1001,
    "user_id": 1,
    "model": "doubao-lite",
    "created_at": "2025-01-01T12:00:00Z"
  }
}
```

---

### 4.3 删除调用记录

**接口**  
`DELETE /api/v1/llm/history/{id}`

**响应**

```json
{
  "code": 0,
  "message": "deleted",
  "data": {}
}
```

**核心逻辑**

- 从 `llm_call_logs` 中删除对应记录。

---

## 5. 鉴权与 Token 设计

### 5.1 Token 类型

- `access_token`：
  - 建议使用 JWT
  - 有效期短（例如 1 小时）
  - 仅包含必要信息：`sub`(user_id)、`exp`、`iat` 等
- `refresh_token`：
  - 建议同样使用 JWT 或随机字符串
  - 有效期长（例如 30 天）
  - 可以包含 `jti`（唯一 ID），在数据库中存储并管理

### 5.2 JWT Payload 示例

```json
{
  "sub": "1",
  "exp": 1735689600,
  "iat": 1735686000,
  "type": "access"
}
```

- `sub`：用户 ID
- `type`：区分 access / refresh
- 签名密钥使用环境变量配置（例如 `.env` 中配置）

### 5.3 鉴权中间件流程

- 从 `Authorization` 头部解析 `Bearer <token>`。
- 验证签名与 `exp`。
- 解析 `sub` 获取 `user_id`。
- 将 `user_id` 注入到请求上下文，供业务 handler 使用。
- 对需要登录的接口统一使用该中间件。

---

## 6. MySQL 表结构设计

以下为推荐表结构（可根据实际框架迁移语法调整）。

### 6.1 用户表 `users`

```sql
CREATE TABLE `users` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `username` VARCHAR(64) NOT NULL COMMENT '用户名',
  `email` VARCHAR(255) NOT NULL COMMENT '登录邮箱',
  `password_hash` VARCHAR(255) DEFAULT NULL COMMENT '密码哈希值(第三方登录可为空)',
  `avatar_url` VARCHAR(512) DEFAULT NULL COMMENT '头像URL',
  `status` TINYINT NOT NULL DEFAULT 1 COMMENT '状态:1正常,0禁用',
  `oauth_provider` VARCHAR(32) DEFAULT NULL COMMENT '第三方登录提供商 (如: google, wechat)',
  `oauth_id` VARCHAR(128) DEFAULT NULL COMMENT '第三方登录唯一ID',
  `last_login_at` DATETIME DEFAULT NULL COMMENT '最近登录时间',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `is_deleted` TINYINT NOT NULL DEFAULT 0 COMMENT '软删除标记:0否,1是',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_username` (`username`),
  UNIQUE KEY `uk_email` (`email`),
  KEY `idx_oauth` (`oauth_provider`, `oauth_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

---

### 6.2 用户 Token 表 `user_tokens`

用于管理 refresh token（可实现注销、单点登录等）。

```sql
CREATE TABLE `user_tokens` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `token` VARCHAR(512) NOT NULL COMMENT 'refresh token 或其标识',
  `user_agent` VARCHAR(512) DEFAULT NULL COMMENT '用户UA信息',
  `ip` VARCHAR(64) DEFAULT NULL COMMENT '登录IP',
  `expires_at` DATETIME NOT NULL COMMENT '过期时间',
  `revoked` TINYINT NOT NULL DEFAULT 0 COMMENT '是否已吊销',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_user` (`user_id`),
  KEY `idx_token` (`token`(191))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户Token表';
```

> 如果不想存全量 token，可仅存 `jti` 或 hash 值。

---

### 6.3 密码重置 Token 表 `password_reset_tokens`

```sql
CREATE TABLE `password_reset_tokens` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `reset_token` VARCHAR(255) NOT NULL COMMENT '密码重置token',
  `expires_at` DATETIME NOT NULL COMMENT '过期时间',
  `used` TINYINT NOT NULL DEFAULT 0 COMMENT '是否已使用',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_reset_token` (`reset_token`),
  KEY `idx_user` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='密码重置Token表';
```

---

### 6.4 LLM 调用历史表 `llm_call_logs`

```sql
CREATE TABLE `llm_call_logs` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `model` VARCHAR(128) NOT NULL COMMENT '模型名称',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '调用时间',
  PRIMARY KEY (`id`),
  KEY `idx_user_created` (`user_id`, `created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='LLM调用历史表';
```

---

## 7. 安全与隐私考虑

- 密码永不明文存储，只存哈希值。
- 所有与 Token 相关的密钥放在环境变量（`.env`）中，不写入代码仓库。
- LLM 调用历史：
  - 仅记录调用发生的模型与时间，不记录 Prompt 与 Response 内容，最大限度保护用户隐私。
- 跨域与 CSRF：
  - 如为纯前后端分离并采用 Bearer Token，则主要防 XSS。
- 登录保护：
  - 当 `login_failed_count` 超过阈值（例如 5 次），可临时锁定账号或要求验证码。

---

## 8. 与现有系统的集成思路

- 在现有 `backend`（如 `main.py`）中：
  - 增加一组 `auth` 路由与 `llm` 历史路由。
  - 将 LLM 调用的 service 层统一封装，调用完成后在同一处写 `llm_call_logs`。
- 未来扩展：
  - 可基于 `users` 表增加角色、权限、会员等级等字段。
  - 可以增加 `user_settings` 表，用于保存用户偏好，如偏好城市、预算范围等。

---

## 9. 后续落地步骤建议

1. 在数据库中建表：`users`、`user_tokens`、`password_reset_tokens`、`llm_call_logs`。  
2. 在后端创建统一的密码哈希与 Token 工具模块。  
3. 实现上述 `auth` 相关接口（注册、登录、刷新、忘记密码等）。  
4. 在所有需要用户身份的接口上集成鉴权中间件。  
5. 在 LLM 调用流程中增加调用日志写入。  

> 本文档为初版设计，可在实际开发过程中根据已有框架和业务细节进行微调。